// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
)

const getInviteByUUID = `-- name: GetInviteByUUID :one
SELECT id, uuid, name, max_adults, max_kids, attending, adult_count, kid_count, dietary_info, message_for_us, song_request, response_at, response_country, sheet_row, synced_at, deleted_at, created_at, updated_at FROM invites
WHERE uuid = ? AND deleted_at IS NULL
`

func (q *Queries) GetInviteByUUID(ctx context.Context, uuid string) (Invite, error) {
	row := q.db.QueryRowContext(ctx, getInviteByUUID, uuid)
	var i Invite
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Name,
		&i.MaxAdults,
		&i.MaxKids,
		&i.Attending,
		&i.AdultCount,
		&i.KidCount,
		&i.DietaryInfo,
		&i.MessageForUs,
		&i.SongRequest,
		&i.ResponseAt,
		&i.ResponseCountry,
		&i.SheetRow,
		&i.SyncedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPendingSyncInvites = `-- name: GetPendingSyncInvites :many
SELECT id, uuid, name, max_adults, max_kids, attending, adult_count, kid_count, dietary_info, message_for_us, song_request, response_at, response_country, sheet_row, synced_at, deleted_at, created_at, updated_at FROM invites
WHERE deleted_at IS NULL
  AND response_at IS NOT NULL
  AND (synced_at IS NULL OR response_at > synced_at)
ORDER BY response_at ASC
`

func (q *Queries) GetPendingSyncInvites(ctx context.Context) ([]Invite, error) {
	rows, err := q.db.QueryContext(ctx, getPendingSyncInvites)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Invite{}
	for rows.Next() {
		var i Invite
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Name,
			&i.MaxAdults,
			&i.MaxKids,
			&i.Attending,
			&i.AdultCount,
			&i.KidCount,
			&i.DietaryInfo,
			&i.MessageForUs,
			&i.SongRequest,
			&i.ResponseAt,
			&i.ResponseCountry,
			&i.SheetRow,
			&i.SyncedAt,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markInviteSynced = `-- name: MarkInviteSynced :exec
UPDATE invites
SET synced_at = ?, updated_at = ?
WHERE uuid = ?
`

type MarkInviteSyncedParams struct {
	SyncedAt  sql.NullTime `json:"synced_at"`
	UpdatedAt sql.NullTime `json:"updated_at"`
	Uuid      string       `json:"uuid"`
}

func (q *Queries) MarkInviteSynced(ctx context.Context, arg MarkInviteSyncedParams) error {
	_, err := q.db.ExecContext(ctx, markInviteSynced, arg.SyncedAt, arg.UpdatedAt, arg.Uuid)
	return err
}

const softDeleteInvite = `-- name: SoftDeleteInvite :exec
UPDATE invites
SET deleted_at = ?, updated_at = ?
WHERE uuid = ? AND deleted_at IS NULL
`

type SoftDeleteInviteParams struct {
	DeletedAt sql.NullTime `json:"deleted_at"`
	UpdatedAt sql.NullTime `json:"updated_at"`
	Uuid      string       `json:"uuid"`
}

func (q *Queries) SoftDeleteInvite(ctx context.Context, arg SoftDeleteInviteParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteInvite, arg.DeletedAt, arg.UpdatedAt, arg.Uuid)
	return err
}

const updateRSVP = `-- name: UpdateRSVP :exec
UPDATE invites
SET attending = ?,
    adult_count = ?,
    kid_count = ?,
    dietary_info = ?,
    message_for_us = ?,
    song_request = ?,
    response_at = ?,
    response_country = ?,
    synced_at = NULL,  -- Reset to trigger sync to sheet
    updated_at = ?
WHERE uuid = ? AND deleted_at IS NULL
`

type UpdateRSVPParams struct {
	Attending       sql.NullBool   `json:"attending"`
	AdultCount      sql.NullInt64  `json:"adult_count"`
	KidCount        sql.NullInt64  `json:"kid_count"`
	DietaryInfo     sql.NullString `json:"dietary_info"`
	MessageForUs    sql.NullString `json:"message_for_us"`
	SongRequest     sql.NullString `json:"song_request"`
	ResponseAt      sql.NullTime   `json:"response_at"`
	ResponseCountry sql.NullString `json:"response_country"`
	UpdatedAt       sql.NullTime   `json:"updated_at"`
	Uuid            string         `json:"uuid"`
}

// Update RSVP response and reset synced_at to trigger sync to Google Sheets
// The CASE statement ensures synced_at is set to NULL only when response data changes
func (q *Queries) UpdateRSVP(ctx context.Context, arg UpdateRSVPParams) error {
	_, err := q.db.ExecContext(ctx, updateRSVP,
		arg.Attending,
		arg.AdultCount,
		arg.KidCount,
		arg.DietaryInfo,
		arg.MessageForUs,
		arg.SongRequest,
		arg.ResponseAt,
		arg.ResponseCountry,
		arg.UpdatedAt,
		arg.Uuid,
	)
	return err
}

const upsertInvite = `-- name: UpsertInvite :exec
INSERT INTO invites (uuid, name, max_adults, max_kids, sheet_row, synced_at, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(uuid) DO UPDATE SET
    name = excluded.name,
    max_adults = excluded.max_adults,
    max_kids = excluded.max_kids,
    sheet_row = excluded.sheet_row,
    -- Preserve existing synced_at on UPDATE (don't overwrite with new timestamp)
    synced_at = invites.synced_at,
    updated_at = excluded.updated_at,
    deleted_at = NULL
`

type UpsertInviteParams struct {
	Uuid      string        `json:"uuid"`
	Name      string        `json:"name"`
	MaxAdults int64         `json:"max_adults"`
	MaxKids   int64         `json:"max_kids"`
	SheetRow  sql.NullInt64 `json:"sheet_row"`
	SyncedAt  sql.NullTime  `json:"synced_at"`
	CreatedAt sql.NullTime  `json:"created_at"`
	UpdatedAt sql.NullTime  `json:"updated_at"`
}

// Upsert invite data from Google Sheets
// Only updates master data (name, max_adults, max_kids, sheet_row)
// Preserves RSVP data and synced_at timestamp if record already exists
// On INSERT: sets synced_at to the provided timestamp
// On UPDATE: preserves existing synced_at (even if NULL) to maintain RSVP sync state
func (q *Queries) UpsertInvite(ctx context.Context, arg UpsertInviteParams) error {
	_, err := q.db.ExecContext(ctx, upsertInvite,
		arg.Uuid,
		arg.Name,
		arg.MaxAdults,
		arg.MaxKids,
		arg.SheetRow,
		arg.SyncedAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}
